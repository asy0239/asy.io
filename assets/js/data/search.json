[ { "title": "여러 Git 브랜치 전략 소개", "url": "/posts/%EC%97%AC%EB%9F%AC-Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EC%A0%84%EB%9E%B5-%EC%86%8C%EA%B0%9C/", "categories": "Git, 브랜치 전략", "tags": "개념, 소개", "date": "2022-06-16 02:32:30 +0900", "snippet": "목표 여러 Git 브랜치를 소개합니다. Mirero 또는 각 프로젝트에 적용하면 좋을 Git 브랜치 전략이 있는지 토론합니다. 브랜치 전략이 왜 필요한가? 대부분의 프로젝트는 혼자가 아닌 디자이너, 퍼블리셔, 개발자 등의 많은 구성원들로 진행됩니다. 이로 인해 프로젝트의 형상 관리가 어려워, 형상 관리의 복잡성을 줄이기 위해 적절한 브랜치 관리 전략이 필요합니다. 브랜치 전략 종류 브랜치 전략 종류는 다양하게 있습니다. Git Flow Gitlab Flow Github Flow Centralized Workflow Feature Branch Workflow Forking Workflow 이 중 Git Flow, Gitlab Flow, Github Flow 가 가장 보편적으로 사용하는 전략입니다.Git Flow GitFlow 는 5가지 브랜치를 사용합니다. 1. Master Branch 제품으로 출시될 수 있는 브랜치(배포)기준이 되는 브랜치 2. Develop Branch 다음 출시 버전을 개발하는 브랜치이 브랜치를 기준으로 각자 작업한 기능들을 병합 3. Feature Branch 새로운 기능을 추가할 때 사용하는 브랜치단위 기능을 개발하는 브랜치로 개발 완료되면 develop 브랜치에 병합 4. Release Branch 이번 출시 버전을 준비하는 브랜치배포를 위해 master 브랜치로 보내기 전에 품질검사를 하기위한 브랜치, TEST 5. Hotfix Branch 발생한 버그들에 대한 작업을 하는 브랜치배포완료 후 버그 발생 시 긴급 수정하는 브랜치 Git Flow 특징 master 와 develop 이 중요한 Main 브랜치이고 나머지는 필요에 의해 사용 브랜치 merge 시 -no-ff 옵션을 붙여 브랜치에 대한 기록이 사라지는 것을 방지하는 것을 원칙으로 한다.Git Flow 과정(우아한 형제들) master 브랜치에서 develop 브랜치를 분기합니다. 개발자들은 develop 브랜치에 자유롭게 커밋을 합니다. 기능 구현이 있는 경우 develop 브랜치에서 feature-* 브랜치를 분기합니다. 배포를 준비하기 위해 develop 브랜치에서 release-* 브랜치를 분기합니다. 테스트를 진행하면서 발생하는 버그 수정은 release-* 브랜치에 직접 반영합니다. 테스트가 완료되면 release 브랜치를 master와 develop에 merge합니다.Github Flow Git Flow 가 Github 에서 사용하기에는 복잡하다고 나온 브랜치 전략입니다.Github Flow 특징 hotfix 브랜치나 feature 브랜치를 구분하지 않고 우선 순위를 잡고 작업합니다. CI / CD 가 자동화되어있는 프로젝트에 유용합니다. 브랜치 전략이 단순합니다.Github Flow 사용법 1. master 브랜치는 언제든 배포가 가능 master 브랜치는 항상 최신 상태, 제품이 배포되는 브랜치입니다. master 에 병합하기 전에 충분히 테스트 진행합니다. 2. master 에서 브랜치를 만든다면 이름을 명확하게 작성 브랜치는 항상 master 브랜치에서 생성 gitflow 와 다르게 feature, develop 브랜치가 없기 때문에 새로운 기능을 추가하거나 버그 수정 시 브랜치 이름을 자세하게 어떤 일을 하는지 작성합니다. 커밋 메세지를 명확하게 작성합니다. 3. 원격 브랜치로 수시로 push 할 것 항상 원격지에 자신이 하고 있는 일들을 올려 다른 사람들도 확인할 수 있도록 합니다. 하드웨어에 문제가 발생하더라도 원격지에 있는 소스를 받아서 작업할 수 있습니다. 4. 피드백이나 도움이 필요할 때 또는 merge 준비가 완료되었을 때 pull request 생성 pull request 는 코드 리뷰를 도와주는 시스템입니다. pull request 를 이용해 자신의 코드를 공유하고 리뷰 받을 수 있습니다. 5. 기능에 대한 리뷰와 논의가 끝난 후 master 로 병합 곧장 product 로 반영이될 기능이므로, 팀원들과 충분한 논의 이후 반영하도록 합니다. 6. master 로 merge 되고 push 되었을 때는 즉시 배포되어야 합니다. github Flow 의 핵심 master 로 merge 가 일어나면 자동으로 배포가 되도록 설정해놓습니다. 단 CI/CD 가 구축되어야합니다. Gitlab Flow Git Flow 와 Github Flow 의 절충안 정도로 생각됩니다. 1. feature 모든 기능 구현은 feature 브랜치에서 시작합니다. feature 브랜치는 master 브랜치에서 분기되고 병합됩니다. 2. master gitlab flow 의 master 브랜치 역할은 git flow 의 develop 브랜치와 동일합니다. master 브랜치는 feature 브랜치에서 병합된 기능에 대해 test 를 진행합니다. 전체적인 테스트가 진행되어 기능에 대한 보장이 되었다면 production 브랜치로 병합합니다. 만약 staging 단계를 원한다면 pre-production 브랜치로 머지를 진행합니다. 3. production gitlab flow 의 production 브랜치 역할은 git flow 의 master 브랜치와 동일합니다. 테스트가 끝난 기능에 대해 배포를 하기 위한 브랜치입니다. 4. Pre-production master -&gt; production 브랜치 사이에 pre-production 브랜치를 두어 변경 사항을 바로 production 에 배포하지 않고 test server 에 배포하여 통합 테스트를 진행하거나 시간을 두고 반영하는 브랜치입니다. Centralized Workflow 1. 사용법 단일 중앙 저장소를 이용합니다. master 브랜치만을 사용합니다. 2. 충돌 처리 중앙 저장소의 커밋이 기준이 되므로, 로컬 저장소의 변경 내용을 푸시하려면, 저장소의 커밋 이력과 충돌한다면 Git 은 저장소의 커밋을 보호하기 위해 푸시를 거부합니다. 이 때는 중앙 저장소의 변경 내용을 로컬 저장소로 가져와 합치거나(Merge) 재배열(Rebase) 합니다. 합치거나 재배열 도중 충돌이 발생되면 수작업으로 충돌을 해결해야합니다. Feature Branch Workflow Feature Branch Workflow 의 핵심 컨셉은 기능별 브랜치를 만들어서 작업하는 것입니다. master 브랜치는 항상 버그 프리 상태를 유지하며, 병합 시 권한을 가진 사용자가 풀 리퀘스트를 적용할 수 있습니다. Github Flow 와 거의 동일Forking Workflow Forking Workflow 는 하나의 중앙 저장소를 이용하는 것이 아니라, 개개인마다 서로 다른 원격 저장소를 운영하는 방식입니다. 모든 프로젝트 참여자가 개인적인 로컬 저장소와 공개된 원격 저장소, 즉 두 개씩의 Git 저장소를 가지는 방식입니다. 모든 코드 기여자가 하나의 중앙 저장소에 푸시하는 것이 아니라, 각자 자신의 원격 저장소에 푸시하고, 프로젝트 관리자만 다른 개발자들의 기여분을 공식 저장소에 병합할 수 있다는 점이 가장 큰 특장점입니다. 즉, 프로젝트 관리자는 다른 개발자들에게 공식 저장소에 쓸 수 있는 권한을 주지 않고도 다른 개발자의 커밋을 수용할 수 있습니다. 프로젝트와 직접 관련 없는 제 3자 뿐만아니라, 아주 큰 규모의 분산된 팀에서도 안전하게 협업하기에 좋은 방법입니다. 오픈 소스 프로젝트에서 많이 사용하는 방식입니다.DataManager 기본 전략은 github flow 를 따릅니다. master 를 기준으로 업무별(mssr) 머지 리퀘스트를 생성해 작업합니다.현 상황 총 9개의 저장소를 운영하고 있고 기준이 되는 브랜치는 12개가 있습니다.(http://wish.mirero.co.kr/mirero/team/paaim-group/paaim/-/blob/master/Docs/2021%EB%85%84%20CTO%20%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%20%ED%98%84%ED%99%A9%20%EB%B3%B4%EA%B3%A0/2021%EB%85%84%209%EC%9B%94%20DM%20%EC%9C%A0%EC%A7%80%EB%B3%B4%EC%88%98%20%EA%B3%BC%EC%A0%9C%20%ED%98%84%ED%99%A9%20%EB%B3%B4%EA%B3%A0.md)" }, { "title": "모놀리식 아키텍처 vs 마이크로 서비스 아키텍처", "url": "/posts/%EB%AA%A8%EB%86%80%EB%A6%AC%EC%8B%9D-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-vs-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/", "categories": "아키텍처", "tags": "모놀리식, 마이크로 서비스", "date": "2022-04-11 10:32:00 +0900", "snippet": "모놀리식 아키텍처(Monolithic Architecture)모놀리식이란 어떤 서비스를 개발한다고 할 때 무수한 기능들을 하나로 묶어서 관리하는 것입니다.모놀리식 아키텍처의 경우 모든 프로세스가 긴밀하게 결합되고 단일 서비스로 실행됩니다. 따라서 한 프로세스에 대한 수요가 급증하면 해당 아키텍처 전체를 확장해야합니다.장점 End-to-End 테스트가 용이 빠르게 간단한 서비스를 만들 수 있음단점 조그마한 수정 사항이 있어도 전체를 다시 빌드하고 배포 유지보수도 힘듬 덩치가 너무 커져 구동시간이 늘어남 일부분의 오류가 전체 영향을 미침 각 기능에 따라 다른 언어를 선택할 수 없음마이크로 서비스 아키텍처(MicroService Architecture)마이크로 서비스 아키텍처는 어떤 거대한 서비스를 여러 개의 작은 서비스 유닛으로 쪼개어 조합을 하여 만들도록 하는 아키텍처입니다. 각 작은 서비스는 상호 통신이 가능하며 이를 통해 전체 서비스를 구성합니다.장점 유지 보수 용이 거대한 서비스도 빠르게 수정 가능 각 기능에 따라 다른 언어를 선택할 수 있음단점 모니터링이 힘듬 : 각 서비스를 모니터링하면 편할 수 있지만 전체 프로세스를 모니터링하기는 불편할 수 있음 End-to-End 서비스 구동 불편(테스트가 불편)" }, { "title": "도메인 주도 설계(DDD)", "url": "/posts/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EC%84%A4%EA%B3%84(DDD)/", "categories": "DDD", "tags": "설계", "date": "2022-04-10 09:12:00 +0900", "snippet": "이번 포스팅은 도메인 주도 설계를 간단하게 정리합니다. 도메인 주도 설계의 핵심은 아래와 같습니다. 도메인 전문가(기획자)와 개발자가 어떻게 협업할 것인지가 중요 보편 언어 : 누구나 이해할 수 있는 언어를 사용 모델 주도 디자인도메인 이란? 사전적 의미로 영역, 집합 비즈니스 Domain 을 의미 예를 들어 주문, 고객, 주소관리 등등과 같이 분리 실제 사건이 발생하는 집합DDD 의 2가지 종류전략적 설계 비즈니스의 상황(Context : 대상자, 상황)에 맞게 설계 모든 Context 를 이벤트 스토밍을 통해 공유 각 Context 를 그룹핑(Bounded Context) Context Mapping 을 통해 Bounded Context 간의 관계를 정의 전략적 설계의 결과물 : 도메인 모델(서비스를 추상화한 설계도, 분리 &amp; 연결)전술적 설계 더 상세한 부분(Bounded Context 내부) 모델링 Model driven design Aggregate : 각각의 도메인 영역을 대표하는 객체 계층형 아키텍처를 통한 도메인 모델 분리 도메인 이벤트를 통해 도메인을 보다 명확히 모델링이벤트 스토밍 순서Domain Event 정의 (추상화) Event 는 Actor 가 Action 을 해서 발생한 결과 각자 생각나는 Event 를 적고 더 이상 생각이 안 날때까지 정의합니다. 서로 상이하면서 중복된 것을 없애거나 합칩니다. 이벤트가 발생하는 시간 순서대로 정의, 동시에 발생하는 것도 정의 비즈니스 용어로 무슨 일이 발생했는지를 정의하는 것이지 , 시스템 내에서 발생되는 것을 찾지 말아야 합니다.(보편 언어 사용)프로세스 그룹핑 동일한 비즈니스 주제(업무 프로세스)로 이벤트들을 그룹핑합니다. 비즈니스적으로 중요한 핵심 프로세스에 집중합니다. 핵심 프로세스에 중요한 이벤트가 누락되지 않았는지 검포합니다. 지원 프로세스는 너무 자세하게 이벤트를 식별하지 않습니다.Command 정의 사용자의 행위가 Command 가 됩니다. Command 는 일반적으로 ‘무엇을 CRUD 요청한다.’ 또는 ‘무엇을 XX 한다’ 의 형태가 됩니다. 각 Event 별로 그 Event 를 발생시키는 Command 가 무엇인지 생각합니다. Command 하나에 1개 이상의 Event 가 발생할 수 있습니다.Trigger 정의 Command 를 수행하는 Actor 를 정의합니다. Event 발생과 관련된 외부 시스템을 정의합니다.Aggregate 정의 Command 수행을 위해 CRUD 해야 하는 데이터 객체 정의 Command 를 수행해서 Event 발생시키려면 어떤 데이터(정보)가 필요한지 정의Bounded Context 정의 정의된 다양한 Event 를 묶어 놓는 것을 Context 라고 정의 정의된 Context 를 영역을 구분해 정의" }, { "title": "마이크로 서비스 통신 패턴", "url": "/posts/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%86%B5%EC%8B%A0-%ED%8C%A8%ED%84%B4/", "categories": "마이크로서비스", "tags": "통신, 패턴", "date": "2022-04-04 09:12:00 +0900", "snippet": "Synchronous Solution(동기적) REST API 서비스 A 에서 서비스 B 로 직접 요청을 보내고 동기적으로 응답을 기다림Asynchronous Messaging(비동기적) 메시지 브로커를 사용하여 서비스 A 에서 서비스 B 로 메시지를 보냄 서비스 A 는 응답을 기다리지 않음 서비스 B 는 일반적으로 동일한 메시징 시스템을 통해 결과를 사용할 수 있을 때 (결과가 예상되는 경우) 결과를 보냄 RabbitMQ, Apache KafkaSynchronous Solution 의 문제점 Request 하는 Service A 와 Response 하는 Service B 2 개의 Service 가 있을 때 경우 A가 연결을 시도할 때 B가 오프라인 상태일 수 있다. 이런 경우 어딘가에 요청을 저장하고 나중에 다시 시도해야 하는가? 언제 다시 시도해야 하는가? 얼마나 자주 시도해야 하는가? A 가 응답을 기다리는 동안 시간이 오래 걸리거나 실패 할 수 있다. B 가 데이터 처리를 완료했지만 A가 오프라인 상태인 경우 어떻게 처리해야하나? 서로 서비스의 상태에 따라 문제점이 발생할 수 있습니다.Asynchronous Messaging 위와 같은 Synchronous 의 문제점을 Asynchronous Messaging 으로 해결할 수 있습니다. A 에서 B 로 메시지를 전달하고 B에서 A 로 메시지를 전달할 때 중개자 역할하는 메시지 브로커를 사용 메시지 브로커는 A 에서 메시지를 수신하여 B 에게 메시지를 전달하여 작업을 수행 메시지 브로커는 B 의 연결이 끊어졌을 때 임시 메시지 저장소를 제공 마이크로서비스 별도의 독립성 확보" }, { "title": "CI/CD 소개", "url": "/posts/CI-CD-%EC%86%8C%EA%B0%9C/", "categories": "CI CD", "tags": "개념, 소개", "date": "2022-03-04 07:32:30 +0900", "snippet": "CI/CD Concept CI (Continuous Integration) - 지속적 통합 CD (Continuous Delivery or Continuous Deployment) - 지속적 전달 / 배포 소프트웨어 배포 프로세스를 스피드하게하기 위해 프로세스 주기를 짧게하고 자동화된 방식을 채택한 것을 CI/CD 라고 합니다.CI 소스 병합 시 Conflict 를 방지하기 위해서 하루에 수차례 Merge 하는 것을 CI 라고 합니다. 전통적인 소프트웨어 방식이 보완하기 위해 CI 라는 개념이 나옴CI WorkFlows Developer 개발자들이 Local 환경에서 개발 후 Repository 에 Push Repository Push 이벤트를 받아 CI Server 에 전송 CI Server CI 서버는 소스 코드를 컴파일하고 다양한 테스트를 거쳐 Target server 로 배포 Target Server 위 일련의 과정을 CI 라고 합니다.CI Common Practice(CI 성능 척도 항목) Code Repository 유지 관리 추가 종속성을 요구하지 않고 새로운 체크아웃(Clone)에서 애플리케이션을 빌드할 수 있어야 합니다. 자동화된 빌드 및 빠른 빌드 유지 모든 사람이 정한 기준에 매일 커밋하고 모든 커밋을 빌드해야 합니다 모든 버그 수정 커밋은 테스트 케이스와 함께 제공되어야 합니다 프로덕션 환경의 클론에서 테스트CD 소프트웨어 기능을 굉장히 빠르고 자동화된 방식으로 배포하는 것 Continuous Deployment - CI 진행 후 Target Server 까지 자동화 배포 진행 Continuous Delivery - CI 진행 후 반드시 배포가 가능한 상태를 유지하고 배포 담당자에 의해 Target Server 에 배포가 진행됨CI/CD 목적 고객의 요구 사항을 빠르게 해소하기 위해 빠르게 배포를 하기 위함 신뢰성있는 배포를 하기위한 전략" }, { "title": "WPF + Devexpress Bar Chart", "url": "/posts/WPF-Devexpress-Bar-Chart/", "categories": "C#, chart", "tags": "devexpress, bar chart", "date": "2022-01-05 08:30:00 +0900", "snippet": "Bar Chart Devexpress 의 BarSideBySideSeries2D 를 이용하여 Bar Chart 를 그려봅니다.View&lt;Window x:Class=\"WpfApp1.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:local=\"clr-namespace:WpfApp1\" xmlns:dxc=\"http://schemas.devexpress.com/winfx/2008/xaml/charts\" mc:Ignorable=\"d\" Title=\"MainWindow\" Height=\"450\" Width=\"800\"&gt; &lt;dxc:ChartControl DataSource=\"{Binding Data}\"&gt; &lt;dxc:ChartControl.CrosshairOptions&gt; &lt;dxc:CrosshairOptions ShowArgumentLabels=\"True\" ShowValueLabels=\"True\" ShowValueLine=\"True\"/&gt; &lt;/dxc:ChartControl.CrosshairOptions&gt; &lt;dxc:ChartControl.Titles&gt; &lt;dxc:Title Content=\"Sales by Regions\" HorizontalAlignment=\"Center\"/&gt; &lt;/dxc:ChartControl.Titles&gt; &lt;dxc:XYDiagram2D Rotated=\"True\"&gt; &lt;dxc:BarSideBySideSeries2D DisplayName=\"Annual Statistics\" ArgumentDataMember=\"Argument\" ValueDataMember=\"Value\" CrosshairLabelPattern=\"${V:f2}M\"/&gt; &lt;/dxc:XYDiagram2D&gt; &lt;/dxc:ChartControl&gt;&lt;/Window&gt; ChartControl.DataSource 에 Bingding 하기 위해 `DataSource=”{Binding Data}” 를 추가 CrosshairOptions에서 지정한 옵션은 마우스 오버 시 해당 Bar 의 x값과 y값을 보여주는 옵션입니다. XYDialgram2D.Rotated를 이용해 Bar Chart 의 x,y 축 방향을 변경할 수 있습니다. ArgumentDataMember는 Bar 의 속성값이 될 바인딩된 모델 필드명을 지정합니다. ValueDataMember 는 Bar 의 값이 될 바인딩된 모델 필드명을 지정합니다.ViewModelpublic partial class MainWindow : Window{ public ObservableCollection&lt;DataPoint&gt; Data { get; private set; } public MainWindow() { InitializeComponent(); DataContext = this; Data = new ObservableCollection&lt;DataPoint&gt; { new DataPoint { Argument = \"Bar1\", Value = 5.42d }, new DataPoint { Argument = \"Bar2\", Value = 15.42d }, new DataPoint { Argument = \"Bar3\", Value = 25.42d } }; }} DataPoint Model 을 이용하여 ObservableCollection 값을 바인딩합니다. Bar 는 DataPoint 를 사용하여 x값과 y값을 정합니다.Modelpublic class DataPoint{ public string Argument { get; set; } public double Value { get; set; }} Argument 는 X 축 값이 됩니다. Value는 bar 의 값이 됩니다." }, { "title": "Python + 표제어, 어간 추출", "url": "/posts/%EC%96%B4%EA%B0%84-%EC%B6%94%EC%B6%9C(stemming),-%ED%91%9C%EC%A0%9C%EC%96%B4-%EC%B6%94%EC%B6%9C(lemmatization)/", "categories": "python, nltk", "tags": "자연어처리, 데이터가공", "date": "2022-01-04 08:34:00 +0900", "snippet": "어간 추출(Stemming), 표제어 추출(lemmatization)위 두개는 서로 다른 언어들이지만 하나로 일반화 할 수 있으면 일반화하자는 의의,단어 개수를 최대한 줄여보자에 의미가 있다.1. 표제어 추출(lemmatization)표제어 추출은 서로 다른 단어임에도 뿌리를 찾아 단어를 줄일 수 있는지 판단합니다.ex) am, are, is -&gt; be표제어 추출을 하는 가장 섬세한 방법은 형태학적 파싱을 하는 것형태학이랑 형태소로 부터 단어를 만들어가는 학문형태소란 의미를 가진 가장 작은 단위 라는 뜻형태소는 두 가지 종류가 있다. 어간 (stem) : 단어에 의미를 담고있는 단어의 핵심 부분 접사 (affix) : 단어에 추가적인 의미를 주는 부분ex) cats -&gt; cat(어간), -s(접사)import nltkfrom nltk.stem import WordNetLemmatizer ## 표제어 추출 도구2. 어간 추출(stemming)어간 추출은 형태학적 분석을 단순화한 버전이라 보면 된다. 정해진 규칙만을 보고 단어의 어미를 자르는 어림짐작의 작업ex) alize -&gt; al , ance -&gt; 제거 , ical -&gt; ic 등 규칙을 갖는다ex) formalize -&gt; formal, allowance -&gt; allow , electricical -&gt; electricex) this -&gt; thi , was -&gt; wa 등 규칙에 의해 작동되기 때문에 사전에 없는 단어들이 포함될 수 있다.import nltkfrom nltk.stem import PorterStemmers = PorterStemmer()words=['formalize', 'allowance', 'electricical'][s.stem(w) for w in words]## w =&gt; ['formal', 'allow', 'electric']porter 알고리즘을 사용할 때는 porter 알고리즘의 상세규칙을 살펴 볼 필요가 있다.import nltkfrom nltk.stem import LancasterStemmer위에 코드는 porter 와 다른 알고리즘 , 규칙이 조금씩 다르므로 규칙들을 살펴 봐야된다.3. 한국어한국어는 너무 불규칙적이라 사용하기 어려워 보인다. 예를 들어 ‘‘잡다’’ 를 보면 “잡”,”다”를“잡”(어간),”다”(어미)로 구분 된다. 어간(stem) : 용언(동사,형용사)를 사용할 때, 원칙적으로 모양이 변하지 않는 부분, 때로는 어간도 바뀔 수 있음(예: 긋다, 긋고, 그어서, 그어라) 어미(ending) : 용언의 어간 뒤에 붙어 활용하며 변하는 부분, 여러 문법적 기능 수행, 규칙이 있으면 규칙 활용, 불규칙이면 불규칙 활용" }, { "title": "WSL2 + Ubuntu (Windows11)", "url": "/posts/WSL2-+-ubuntu/", "categories": "Linux, WSL 기본 사용법", "tags": "Linux, WSL", "date": "2022-01-04 08:32:00 +0900", "snippet": "WSL2 + Ubuntu WSL 설치 방법이 Windows11 부터 달라져서 정리합니다.WSL(Windows Subsystem for Linux) 윈도우에서 ELF64 바이너리를 실행할 수 있도록 하는 기술 쉽게 말하면 윈도우에서 리눅스 환경을 사용 가능하도록 합니다. 여러 리눅스 배포판 지원 합니다.WSL 설치 요건 설치 요건은 Windows 10 버전 2004 이상(빌드 19041 이상) 또는 Windows 11 입니다.WSL 설치 방법 관리자 권한으로 PowerShell 실행합니다. 기존 방법과는 다르게 wsl --install 명령어로 간단하게 설치가 가능합니다. 가상 머신 플랫폼, Linux 용 Windows 하위 시스템 설치, GUI 앱(Ubuntu) 설치를 자동으로 받아줍니다. wsl –install -d [배포판 이름] 으로 다른 리눅스 배포판을 사용할 수 있습니다. wsl --install 재부팅 실행합니다. 설치된 GUI 앱 실행하여 로그인 ID , 패스워드 입력 후 사용합니다." }, { "title": "AWS CLI 도구 설치 및 사용", "url": "/posts/AWS-CLI-%EB%8F%84%EA%B5%AC-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%82%AC%EC%9A%A9/", "categories": "Linux, WSL 기본 사용법", "tags": "Linux, WSL", "date": "2022-01-04 08:31:00 +0900", "snippet": "AWS CLI 소개 AWS 서비스 관리를 위한 CLI 명령어 도구 2020년 2월 버전 2 출시 AWS CLI 는 Python 기반으로 작성되어 Boto 패키지를 이용 AWS CLI v2 는 Python 3.6 이상 버전을 필요(2021년 8월 기준)AWS 액세스 키 발급 AWS 계정 혹은 IAM 사용자의 액세스 키 발급 필요Access Key ID 자격 증명 주체를 가리킴 인증 요청한 사람이 누구인가??Secret Access Key 자격 증명 주체 본인임을 인증하는 수단 인증 요청한 사람이 정말 A 가 맞는가?발급 순서 AWS 로그인 -&gt; 보안 자격 증명 화면 -&gt; 액세스 키 -&gt; 새 액세스 키 만들기 -&gt; 다운로드AWS CLI 자격 증명 설정AWS CLI 를 이용하려면 본인의 AWS 자격 증명을 설정해야 합니다. 다양한 자격 증명 설정 방법을 지원하는데, 각 설정 방법과 적용 우선순위를 잘 파악해두어야 합니다.이 글에서는 CLI 설정 파일 을 이용해보도록 하겠습니다.AWS CLI 자격 증명 설정 우선 순위아래 정리해둔 리스트에서 위에서 부터 아래로 갈 수록 우선순위가 낮습니다. CLI 명령어 옵션 환경 변수 CLI 자격 증명 파일 : ~/.aws/credentials CLI 설정 파일 : ~/.aws/config 컨테이너 자격 증명 (ECS 의 경우) 인스턴스 프로파일 자격 증명 (EC2 의 경우)AWS CLI 자격 증명 설정 : CLI 설정 파일~/.aws/config[default]aws_access_key_id=ACCESS_KEY_IDaws_secret_access_key=SECRET_ACCESS_KEYAWS CLI 설정파일은 ~/.aws/config 에 위치합니다. 기본 설정과 추가 사용자 프로파일은 설정 파일에서 관리할 수 있습니다.AWS CLI 자격 증명 설정 : 환경 변수환경 변수를 통해 AWS CLI 의 자격 증명을 설정하는 방법은 여러가지입니다.기본적으로 AccessKey 를 설정하는 방법과 사용자 프로파일을 지정하는 방법을 알아두면 좋습니다.AWS CLI 자격 증명 설정 : CLI 명령어 옵션--profileAWS CLI 명령어 옵션은 가장 높은 우선순위를 가지고 있지만 AccessKey 를 지정하는 방법은 없으며, 사용자 프로파일 지정만 가능합니다.AWS CLI 자격 증명 설정 : EC2 인스턴스 프로파일IAM 역할(Role)을 EC2 머신에 부여하기 위한 목적, EC2 내에서 AWS 서비스에 대한 권한을 수행할 수 있게 됨" }, { "title": "Python + 불용어", "url": "/posts/%EB%B6%88%EC%9A%A9%EC%96%B4(stopword)/", "categories": "python, nltk", "tags": "자연어처리, 데이터가공", "date": "2022-01-04 08:30:00 +0900", "snippet": "불용어갖고 있는 데이터에서 유의미한 단어 토큰만을 선별하기 위해 큰 의미가 없는 단어들을 제거하는 작업이 필요함여기서 큰 의미가 없다는 건 너무 자주 등장해서 분석하는데 있어서 큰 도움이 되지 않는다라는 걸 말함i, my , me , the 등 조사, 접미사 같은 단어들을 말하는 데 이러한 단어들을 불용어라 하며NLTK에서는 위와 같은 단어들을 100개 이상 미리 정의해 놓음, 하지만 사용자가 설정가능하며 분석에 따라 불용어의 정의도 달라 질수있음.1. NLTK에서 불용어 확인import nltk from nltk.corpus import stopwords stopwords.words('english')[:10] ['i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you', 'your'] 2. NLTK를 통해서 불용어 제거import nltkfrom nltk.corpus import stopwordsfrom nltk.tokenize import word_tokenizeexample = \"Family is not an important thing. It's everything.\"stop_words = set(stopwords.words('english'))#패키지에 미리정의된 영어불용어를 가져옴word_tokens = word_tokenize(example)result = []for w in word_tokens: if w not in stop_words: result.append(w) print(word_tokens) print(result) ['Family', 'is', 'not', 'an', 'important', 'thing', '.', 'It', \"'s\", 'everything', '.']['Family', 'important', 'thing', '.', 'It', \"'s\", 'everything', '.']위 예시에선 is, not, an 이 제거 됨 It 같은 경우 제거가 안되나 봄3. 한국어에서 불용어 제거한국어는 konlpy 라는 패키지를 이용해 형태소 분석후에 조사, 접속사등을 제거하는 방법이 있다.직접 정의해보는 이번엔 직접 불용어를 정의해 해보자.import nltkfrom nltk.corpus import stopwordsfrom nltk.tokenize import word_tokenizeexample = \"고기를 아무렇게나 구우려고 하면 안 돼. 고기라고 다 같은 게 아니거든. 예컨대 삼겹살을 구울 때는 중요한 게 있지.\"stop_words = \"아무거나 아무렇게나 어찌하든지 같다 비슷하다 예컨대 이럴정도로 하면 아니거든\"## stop_words 는 직접 불용어를 정의한 것stop_words = stop_words.split(' ') ## 띄어쓰기를 기준으로 구분한다.word_tokens = word_tokenize(example)result = []for w in word_tokens: if w not in stop_words: result.append(w) print(word_tokens) print(result)['고기를', '아무렇게나', '구우려고', '하면', '안', '돼', '.', '고기라고', '다', '같은', '게', '아니거든', '.', '예컨대', '삼겹살을', '구울', '때는', '중요한', '게', '있지', '.']['고기를', '구우려고', '안', '돼', '.', '고기라고', '다', '같은', '게', '.', '삼겹살을', '구울', '때는', '중요한', '게', '있지', '.']정의한 불용어 사전은 크게 좋은 결과를 주진 않는 것 같다. 하지만 자신이 무엇을 원하는지가 중요https://www.ranks.nl/stopwords/korean 보편적인 불용어 사전 링크" }, { "title": "지속가능한 SW 개발을 위한 코드리뷰", "url": "/posts/%EC%A7%80%EC%86%8D%EA%B0%80%EB%8A%A5%ED%95%9C-SW-%EA%B0%9C%EB%B0%9C%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/", "categories": "코드 리뷰", "tags": "코드 리뷰", "date": "2021-04-27 07:12:00 +0900", "snippet": "지속가능한 SW 개발을 위한 코드리뷰왜 코드 리뷰를 해야 하나?우리가 살고 있는 시대 4차 산업 혁명 ICT 융합으로 이뤄지는 차세대 산업 혁명 VUCA Volatiliy(변동성) : 변화의 속도가 빠르고 다양하게 전개될 것 Uncertaint(불확실성) : 미래 상황에 변수가 많아 예측하기 어려울 것 Complexity(복잡성) : 인과관계가 단순하지 않고 다양한 요인이 작용될 것 Ambiguity(모호성) : 뚜렷한 현상이 없어 판별하기 어려울 것 변동성의 시대개발 생산성 설계 수익선 아래에서는 일정을 당기기 위해 설계 품질을 희생시키는 것이 의미가 있음 하지만 설계 수익선 이후에는 설꼐 품질 희생이 무의미SW 공학의 특성 공학 = 설계(Design) + 빌드(Build) 설계 : 예측하기 어렵고, 급여가 비싸고 창의적인 사람들을 필요 빌드 : 좀 더 예측하기 쉬움 설계와 빌드가 분리됨 빌드 비용이 비쌈(건축 90%) 공학 활동의 최종 목적 빌드 할 수 있는 어떤 종류의 재생산 가능한 문서 SW 공학의 설계와 빌드 설계 = 완전한 소스코드 SW 빌드 = 컴파일 좋은 설계 ~= 클린 코드 SW 엔지니어 : 설계를 잘하는 사람 -&gt; 코드를 잘 작성하는 사람 클린 코드의 중요성 SW 의 진정한 비용 ~= 유지보수(전체의 80% 이상) 한번 작성한 코드는 10번 이상 읽음. 작성 보다 이해에 10배의 노력 소요 90% 이상의 시간을 어떤 코드를 이해하는데 사용함 SW 개발의 단순한 진리 시간이 흘러도 생산성 저하, 비용 증가를 막을 수 있는 유일한 방법 SW 품질에 신중해야 SW 의 비용과 품질의 관계는 비정상적, 비직관적 향후 변경 비용을 낮춤으로써 익숙한 트레이드오프를 역전 시킴 장인 정신 애자일 VUCA 시대에 더 좋은 SW 개발 방법론 단순 절차 변경 ? 개발 역량 ? 장인 정신 지식과 경험의 공유 만이 전문성을 갖춘 개발자 육성 후배들에게 지식과 경험을 공유(도제 관계) 코드 리뷰 개발자가 지금부터 당장 행할 수 있는 공유 활동 Code SNS 댓글 놀이 배움을 주고 받으면 지속가능한 SW 개발자가 될 수 있는 실천법 목적 주목적 : 품질 문제 검수(버그,장애) 더 나은 코드 품질 : 아키텍처 속성 개선을 위한 코드 개선(향후 변경 비용 개선) 학습 및 지식 전달 : 코드, 해결책 등과 관련된 지식 공유에 기여 공유(주고 받는 학습)를 통한 역량 증대 및 성장 대개의 경우 리뷰어들도 리뷰 과정에서 지식을 얻게됨 상호 책임감 증대 집단 코드 오너십 및 결속 증대 내가 하고 있는 일에 관심을 가져주는 것 팀에서 일어나는 일 공유, 내 동료는 무엇을 하나? 설계 개선 제안 개발 문화 개선코드 리뷰의 절차 저자(Author) 코드 작성, 리뷰 요청 리뷰어 코드를 읽고 머지 가능한지 결정 변경 내역(Change List, PR) 리뷰 시작전에 작성 저자가 머지를 원하는 소스 코드에 대한 일련의 변경(잘한 것, 아쉬운 것, 눈여겨 볼 것)에 대해 기술 왜 코드 리뷰가 어려운가 코드 리뷰는 지식 / 공학적 결정을 공유하는 기회 공유(잘한 것, 아쉬운 것)를 통해 서로의 지식/경험을 나누며 상호 학습을 통한 역량 증대 수단 코드 토의를 개인적 공격으로 받아들이면 물거품 생각을 글로 전달하는 것에 대한 어려움 오해의 위험이 큼(음성 톤, 표정의 부재) 피드백을 조심스럽게 표현하는 것이 더 중요기법들효율적인 PR 방법 지루한 작업은 컴퓨터로 처리 코드를 읽는 것은 인지적 부담이되는 고수준의 집중이 요구되는 작업 컴퓨터가 할 수 있는 있는 일에 이런 노력 낭비를 하지 말라 심지어 기계가 더 잘 할 수 있는 일에 Formmatting Tool 공백, 들여쓰기 오류 등 별도의 커밋/PR 로 분리, 리뷰 불필요를 기술해서 리뷰를 생략할 수 있도록 스타일 가이드를 통해 스타일 논쟁을 해소 스타일에 대한 논쟁은 리뷰에서 시간 낭비 PR을 올릴 때 주석 달기 PR을 저자가 먼저 읽고 -&gt; 리뷰어들을 위한 설명을 커맨트로 남겨서 -&gt; 리뷰어들의 시간을 절약할 수 있게 하라 많은 사람들이 볼 수록 버그를 더 잘 찾아낼 수 있다 모두를 포함하라 의미있는 커밋으로 분리효율적인 리뷰 방법리뷰는 즉시 시작 아침 스탠드 미팅에 익숙 PR에 포함된 변경이 적도록 노력 근본적인 문제는 사람들이 리뷰할 시간이 없다고 느낌 당신의 개인 기여로 평가를 받고 있다면 팀을 돕기 위해 수행하는 모든 일들이 시간 낭비처럼 보임 리뷰를 하는 것의 문제라기보단 조직적인 문제 Pull Requests VS Pair Programming 두 가지 중 선택해서 하는 것보다 상황에 따라 달라짐 고수준으로 시작, 저수준으로 리뷰 라운드에서 많은 의견을 남길 수록, 저자가 당황할 위험 커짐 하나의 라운드에 20~50개 정도의 의견은 위험의 시작 초기 라운드에서는 고수준 피드백으로 제한 버그, 장애, 성능, 보안 등 고수준의 피드백이 처리된 후에 저수준 이슈를 처리 변수명 예제 코드 제공에 관대해라 저자를 기분 좋게 하기위한 방법 리뷰 중 코드 예제 너무 긴 예제는 관대한 것이 아니라 억압적으로 보임리뷰의 범위를 존중하라 자주 보이는 Anti-Pattern PR 근처의 코드를 보고 저자에게 수정을 요청 한 두 등급만 코드 레벨을 올리는 것을 목표로 완전하지 않아도 충분히 좋은 코드가 되도록피드백 방법 절대 “너”라고 하지마라 건설적인 피드백을 하라 진정한 칭찬을 해라 피드백은 명령이 아니라 요청으로 표현해라 의견이 아니라 원칙에 기반하여 피드백해라 반복적인 패턴에 대해서 피드백을 제한하라교착 상태 시교착 상태를 적극저긍로 처리해라 코드 리유의 최악의 결과는 교착 상태 커멘트를 반영하지 않으니 승인거부 저자는 커멘트 반영 거부 만나서 얘기하라 화상 혹은 만나서 논의 텍스트 기반의 소통은 상대가 인간이라는 것을 잊게 함 인정하거나 Escalate 하라 교착 상태가 길어지면 관계가 나빠짐 그냥 승인하는 비용 동료와 너무 다퉈서 함께 일하지 않게 된다면 고수준의 품질을 얻을 기호가 사라짐 인정이 불가한 경우 저자에게 논의를 팀장이나 테크 리더에게 Escalation\\ 다른 리뷰어에게 할당 교착 상태로 부터 회복 상황을 관리자와 논의하라 휴식을 가져라 갈등 해결책을 학습하라 설계 리뷰를 고려하라추가적인 사례코드 리뷰를 하는 재밌는 방법 결정은 저자가 모든 설계 결함이 항상 실제로 문제가 되지 않음 코드 리뷰의 목적은 비난이 아니라 배움이다Appendix코드 리뷰 문화 정착의 어려움 저자의 노력 리뷰어 n 명의 시간을 절약 효과적인 리뷰 가능 리더의 관심과 의지 가끔 , 그러나 매우 자세히 코드 비난에 대한 두려움 없애야함 멋져 보여야 하고 싶어짐, 그게 뭐든, 따라 하고 싶어져야 " }, { "title": "web.xml 설명", "url": "/posts/web.xml-%EC%84%A4%EB%AA%85/", "categories": "Spring, Spring 기초", "tags": "Spring, 환경설정", "date": "2021-04-01 16:53:00 +0900", "snippet": "web.xml 설명web.xml은 서버 (WAS)가 운영하기 위한 내용을 작성 자바 기반의 웹 애플리케이션이라면 무조건 있어야 함 (jsp/spring/…) xmlns : xml name space 의 줄임말, 태그 정보를 제공전역(global) 설정 파일을 지정( context-param 태그) 스프링 전체에 영향을 미치는 설정 이름은 무조건 contextConfigLocation 이라고 작성 요청처리와 상관없는 설정이 들어감 데이터베이스 or 이메일 발송 등 …Spring 에서 사용자의 모든 요청을 처리하는 핵심(core) 서블릿 = 중앙 제어 서블릿(servlet 태그) 요청처리 교통정리, 콜센터, 분배기 개념 만드려면 난이도가 너무 높아서 스프링에서 사용하도록 만들어서 제공 이름 : appServlet 클래스 : org.springframework.web.servlet.DispatcherServlet 초기 설정 : 설정파일 : servlet-context.xml mapping pattern(url-pattern 태그) : / : 전부다(원한다면 제외 할 수 있음, 나머지 전부 다) /* : 전부다(하나도 빠짐없이) *.me : 위치 상관없이 .me 로 끝나는 주소 여러개로 나누어진 설정파일들을 연결해주는 도구 (listener 태그)단, 반드시 전역 설정(root-context.xml)이 서블릿 설정보다 상위에 존재한다." }, { "title": "Spring 기초", "url": "/posts/Spring-%EA%B8%B0%EC%B4%88/", "categories": "Spring, Spring 기초", "tags": "Spring, 기초", "date": "2021-04-01 12:53:23 +0900", "snippet": "Spring 기초1. 스프링 정의 JAVA 플랫폼을 위한 오픈소스(open Source) 애플리케이션 프레임워크 JAVA 엔터프라이즈 개발을 편하게 해주는 오픈 소스 경량급 애플리케이션 프레임워크 JAVA 개발을 위한 프래임워크로 종속 객체를 생성해주고 , 조립해주는 도구 JAVA 로 된 프레임워크로 JAVA SE 로 된 자바 객체(POJO)를 자바EE에 의존적이지 않게 연결해주는 역할2 . 스프링 특징 크기와 부하의 측면에서 경량 제어 역행(IOC)이라는 기술을 통해 애플리케이션의 느슨한 결합을 도모 관점지향(AOP) 프로그래밍을 위한 풍부한 지원을 함 애플리케이션 객체의 생명 주기와 설정을 포함하고 관리한다는 점에서 일종의 컨테이너(Container)라고 할 수 있음 간단한 컴포넌트로 복잡한 애플리케이션을 구성하고 설정할 수 있음2.2) 스프링 특징 크기와 부하의 측면에서 경량. 제어 역행(IoC)이라는 기술을 통해 애플리케이션의 느슨한 결합을 도모. 관점지향(AOP) 프로그래밍을 위한 풍부한 지원을 함. 애플리케이션 객체의 생명 주기와 설정을 포함하고 관리한다는 점에서 일종의 컨테이너(Container)라고 할 수 있음. 간단한 컴포넌트로 복잡한 애플리케이션을 구성하고 설정할 수 있음.- 스프링의 특징을 좀 더 상세히 말하자면 -1) 경량 컨테이너로서 자바 객체를 직접 관리, 각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.2) 스프링은 POJO(Plain Old Java Object) 방식의 프레임워크, 일반적인 J2EE 프레임워크에 비해 구현을 위해 특정한 인터페이스를 구현하거나 상속을 받을 필요가 없어 기존에 존재하는 라이브러리 등을 지원하기에 용이하고 객체가 가볍다.3) 스프링은 제어 반전(IoC : Inversion of Control)을 지원, 컨트롤의 제어권이 사용자가 아니라 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다.4) 스프링은 의존성 주입(DI : Dependency Injection)을 지원, 각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.5) 스프링은 관점 지향 프로그래밍(AOP : Aspect-Oriented Programming)을 지원, 따라서 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.6) 스프링은 영속성과 관련된 다양한 서비스를 지원, iBatis나 Hibernate 등 이미 완성도가 높은 데이터베이스 처리 라이브러리와 연결할 수 있는 인터페이스를 제공한다.7) 스프링은 확장성이 높음, 스프링 프레임워크에 통합하기 위해 간단하게 기존 라이브러리를 감싸는 정도로 스프링에서 사용이 가능하기 때문에 수많은 라이브러리가 이미 스프링에서 지원되고 있고 스프링에서 사용되는 라이브러리를 별도로 분리하기도 용이하다.출처 : http://ko.wikipedia.org/wiki/%EC%8A%A4%ED%94%84%EB%A7%81_%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AChttps://ooz.co.kr/170" }, { "title": "Spring DI , IOC", "url": "/posts/Spring-DI-,-IOC/", "categories": "Spring, Spring 기초", "tags": "Spring, 기초", "date": "2021-04-01 12:53:01 +0900", "snippet": "Spring DI , IOC1. DI(Dependency Injection) - 종속성 주입 or 의존성 주입// Composition has Aclass A { private B b; public A() { b = new B(); }}// Association has Aclass A {\tprivate B b;\tpublic A(){\t\t}\tpublic void setB(B b) {\t\tthis.b = b;\t}}// Composition has A 일 경우A a = new A();// 을 A 를 할당하면 B 가 무조건 결정이 되는 상황// Association has A 일 경우B b = new B();A a = new A();a.setB(b);// 이런 식으로 B 를 선택식으로 할당이 가능하다. 이것을 부품을 조립한다라고도 한다.// 이 방식도 2가지가 있다.// Setter InjectionB b = new B();A a = new A();a.setB(b);// Construction InjectionB b = new B();A a = new A(b); DI 는 Spring 이 가지고 있는 하나의 기능이다. 코드의 결합성을 낮게 해주는 의미 ex) dao 의 코드가 수정 및 추가,삭제가 되어도 service에 있는 코드도 많이 바뀌게 된다.DI 를 이용하면 Service 의 수정작업이 줄일수 있다. 객체간의 의존성을 자신이 아닌 외부에서 주입하는 개념이다. 2. IOC(Inversion of Control) - 제어의 역전 스프링을 쓰기 전에는 개발자가 프로그램의 흐름(애플리케이션 코드) 제어하는 주체였지만 스프링에서는 프로그램의 흐름을 프레임워크가 주도하게 된다. 즉 제어권이 컨테이너로 넘어가게 되고, 이것을 제어권의 흐름이 바뀌었다고 하여 ioc, 제어의 역전이라 한다. 이것으로 인해 DI(의존성 주입), AOP(관점 지향 프로그래밍)이 가능하게 된다.2. IOC(Inversion of Container) 모든 작업을 사용하는 쪽에서 제어하게 되면서 IOC 컨테이너에서 제어하게 되는데 , 기본적으로 컨테이너는 객체를 생성하고 객체가의 의존성을 이어주는 역할을 한다." }, { "title": "Spring 환경설정", "url": "/posts/Spring-%ED%99%98%EA%B2%BD%EC%84%A4%EC%A0%95/", "categories": "Spring, Spring 기초", "tags": "Spring, 환경설정", "date": "2021-04-01 12:52:05 +0900", "snippet": "Spring 환경설정 STS 설치 4버전과 3버전이 있는데 목적에 따라 버전을 선택을 해서 진행해야함 STS download 검색해서 운영체제에 따라 맞게 다운 진행 환경변수 설정 자바 환경변수와 동일하게 설정을 해주면된다. STS tool 실행 인코딩 설정, context type -&gt; java class file , text -&gt; utf-8 workspace, css, html, jsp, json, xml, spelling 모두 utf-8 로 진행 preferences -&gt; java -&gt; compiler -&gt; 버전 맞추기 -&gt; installed jres -&gt; add 사용할 버전 추가 서버 설정 tomcat을 사용할 것이므로 기존 vm 서버는 삭제후 tomcat 추가 legacy project 생성 pom.xml 의 자바 버전과 spring framework 의 버전을 맞추어야함 pop.xml은 maven 을 사용한다. maven 설치 maven download -&gt; 다운로드 파일 경로 (bin 전까지) 환경변수에 추가 maven 연동 settings.xml 수정 -&gt; 기본 다운로드 위치 설정 preferences -&gt; user setting -&gt; browse 로 settings.xml 을 선택하고 update installations -&gt; add -&gt; maven 위치 경로 , 근데 기본 maven이 있어 해도되고 안해도된다. " }, { "title": "Spring | root-context.xml", "url": "/posts/root-context.xml-%EC%84%A4%EB%AA%85/", "categories": "Spring, Spring 기초", "tags": "Spring, 환경설정", "date": "2021-04-01 12:50:01 +0900", "snippet": "root-context.xml 설명root-context.xml 설명전역 설정 파일(root-context.xml) 요청과 관계없는 도구들을 이곳에 등록 beans 태그 사이에 bean 이라는 태그로 등록 xmlns:xsi는 품질보증서, xml 파일이라고 명시를 해준다 생각하면된다. 태그앞으로 스프링에서 사용할 도구가 있다면 bean 태그로 등록, 내가 new로 만드는 것이 아니라 Spring 에서 singleton으로 생성해준다스프링의 1번째 특징 - IoC(Inversion of Control, 제어의 역전) id : 이름(식별자) class : 등록할 도구의 위치데이터 베이스 연결만 처리하는 도구 : 추가적으로 정보 제공이 필요하다. constructor-args : 생성자를 통한 정보 전달(필수) property : setter 메소드를 통한 정보 전달(선택)&lt;bean id=\"dataSource\" \t\t\t\t class=\"org.springframework.jdbc.datasource.DriverManagerDataSource.class\"&gt;&lt;/bean&gt;Spring 에서 기본적으로 제공하는 명령 실행 도구를 등록 - JDBCTemplate 필요한 정보 : 연결 도구(dataSource) 의존성 주입(DI , Dependency Injection) : 필요하니까 주입하여 사용하도록 요청&lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt;\t&lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; 위에 있는 dataSource를 가져온다.&lt;/bean&gt;DBCP 방식의 연결을 수행하는 도구 기존 연결도구 정보 + 관리정보 maxTotal : 관리할 총 연결의 개수 maxIdle : 여유분으로 연결해둘 연결의 최대 개수 minIdle : 여유분으로 연결해둘 연결의 최소 개수 maxWaitMillis : 연결이 모자를 경우 최대 대기시간&lt;bean id=\"dataSource2\" class=\"org.apache.commons.dbcp2.BasicDataSource\"&gt;\t&lt;property name=\"driverClassName\" value=\"oracle.jdbc.OracleDriver\"&gt;&lt;/property&gt;\t&lt;property name=\"url\" value=\"jdbc:oracle:thin:@localhost:1521:xe\"&gt;&lt;/property&gt;\t&lt;property name=\"username\" value=\"springuser\"&gt;&lt;/property&gt;\t&lt;property name=\"password\" value=\"springuser\"&gt;&lt;/property&gt;\t\t\t\t\t&lt;property name=\"maxTotal\" value=\"20\"&gt;&lt;/property&gt;\t\t\t&lt;property name=\"maxIdle\" value=\"10\"&gt;&lt;/property&gt;\t\t\t&lt;property name=\"maxWaitMillis\" value=\"3000\"&gt;&lt;/property&gt;\t\t&lt;/bean&gt;" }, { "title": "python + Django 간단한 앱 만들기", "url": "/posts/python-+-Django-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%95%B1-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "python, django", "tags": "Web", "date": "2021-03-16 03:32:00 +0900", "snippet": " Django 를 이용하여 간단한 앱을 만듭니다.1. 앱 만들기 django 를 설치는 여기 글 참고하여 설치합니다.python manage.py startapp 앱이름 위 명령어는 프로젝트안에 하나의 앱을 생성하는 명령어입니다. App 폴더엔 migrations 폴더와 init.py, admin.py, apps.py, models.py, tests.py, views.py 가 생성됩니다.2. View 작성 polls/views.pyfrom django.http import HttpResponse# Create your views here.def index(request): return HttpResponse(\"Hello, world. You`re at the polls index.\") polls/urls.py(polls 에 자동 생성안되어 추가)from django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index, name='index')]python manage.py runserver 127.0.0.1:8000/polls 로 들어가면 view 에서 작성한 내용을 확인 할 수 있습니다.출처 : https://www.djangoproject.com/start/" }, { "title": "Python + Django 기초", "url": "/posts/Python-Django-%EA%B8%B0%EC%B4%88/", "categories": "python, django", "tags": "Web", "date": "2021-03-14 07:32:00 +0900", "snippet": " 이번 포스팅은 Django 의 기초를 정리해봅니다.1. django 기초 및 설치 django 를 설치하면서 기초적인 내용을 정리합니다. django 는 python 을 기초로 하기 때문에 python 을 미리 설치하고 진행해야합니다. 이번 포스팅은 python 이 설치되어 있다는 것을 전제로 진행합니다.1. 1 django 설치python -m pip install Django1.2 프로젝트 만들기 하나의 앱을 만들기 위한 폴더를 생성한다고 생각할 수 있습니다. 명령어를 입력하면 기본적인 세팅 파일들이 생성됩니다. 명령어는 cmd 창에서 현재 위치한 곳에 폴더가 생성됩니다.django-admin startproject 폴더명(프로젝트명)1.3 생성된 파일 정리 manage.py : django 의 서버를 운영하는 중심적인 역할, main 클래스 setting.py : django 의 다양한 설정을 코드화하여 보여줍니다. SECRET_KEY, TEMPLATES, DB 정보 등 여러 설정들을 관리 및 저장합니다. url.py : url 관련된 모든 활동을 정리합니다. 예를 들면 어느 Url 이 들어왔을 때 어디로 보내주는지 정리해놓습니다.2. 프로젝트 실행하기 위에서 설치한 내용으로 프로젝트를 실행할 수 있습니다.python manage.pu runserver 기본적인 설치만 진행 후 runserver 하면 django 화면이 뜨면 성공적으로 장고가 설치되었습니다.출처 : https://www.djangoproject.com/start/" } ]
