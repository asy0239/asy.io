<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://asy0239.github.io/</id><title>ASY`s blog</title><subtitle>A minimal, responsive, and powerful Jekyll theme for presenting professional writing.</subtitle> <updated>2022-08-03T13:57:29+09:00</updated> <author> <name>asy</name> <uri>https://asy0239.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://asy0239.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://asy0239.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 asy </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>여러 Git 브랜치 전략 소개</title><link href="https://asy0239.github.io/posts/%EC%97%AC%EB%9F%AC-Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EC%A0%84%EB%9E%B5-%EC%86%8C%EA%B0%9C/" rel="alternate" type="text/html" title="여러 Git 브랜치 전략 소개" /><published>2022-06-16T02:32:30+09:00</published> <updated>2022-06-16T02:32:30+09:00</updated> <id>https://asy0239.github.io/posts/%EC%97%AC%EB%9F%AC-Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EC%A0%84%EB%9E%B5-%EC%86%8C%EA%B0%9C/</id> <content src="https://asy0239.github.io/posts/%EC%97%AC%EB%9F%AC-Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EC%A0%84%EB%9E%B5-%EC%86%8C%EA%B0%9C/" /> <author> <name>asy</name> </author> <category term="Git" /> <category term="브랜치 전략" /> <summary> 목표 여러 Git 브랜치를 소개합니다. Mirero 또는 각 프로젝트에 적용하면 좋을 Git 브랜치 전략이 있는지 토론합니다. 브랜치 전략이 왜 필요한가? 대부분의 프로젝트는 혼자가 아닌 디자이너, 퍼블리셔, 개발자 등의 많은 구성원들로 진행됩니다. 이로 인해 프로젝트의 형상 관리가 어려워, 형상 관리의 복잡성을 줄이기 위해 적절한 브랜치 관리 전략이 필요합니다. 브랜치 전략 종류 브랜치 전략 종류는 다양하게 있습니다. Git Flow Gitlab Flow Github Flow Centralized Workflow Feature Branch Workflow Forking Workf... </summary> </entry> <entry><title>모놀리식 아키텍처 vs 마이크로 서비스 아키텍처</title><link href="https://asy0239.github.io/posts/%EB%AA%A8%EB%86%80%EB%A6%AC%EC%8B%9D-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-vs-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/" rel="alternate" type="text/html" title="모놀리식 아키텍처 vs 마이크로 서비스 아키텍처" /><published>2022-04-11T10:32:00+09:00</published> <updated>2022-04-11T10:32:00+09:00</updated> <id>https://asy0239.github.io/posts/%EB%AA%A8%EB%86%80%EB%A6%AC%EC%8B%9D-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-vs-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/</id> <content src="https://asy0239.github.io/posts/%EB%AA%A8%EB%86%80%EB%A6%AC%EC%8B%9D-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-vs-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/" /> <author> <name>asy</name> </author> <category term="아키텍처" /> <summary> 모놀리식 아키텍처(Monolithic Architecture) 모놀리식이란 어떤 서비스를 개발한다고 할 때 무수한 기능들을 하나로 묶어서 관리하는 것입니다. 모놀리식 아키텍처의 경우 모든 프로세스가 긴밀하게 결합되고 단일 서비스로 실행됩니다. 따라서 한 프로세스에 대한 수요가 급증하면 해당 아키텍처 전체를 확장해야합니다. 장점 End-to-End 테스트가 용이 빠르게 간단한 서비스를 만들 수 있음 단점 조그마한 수정 사항이 있어도 전체를 다시 빌드하고 배포 유지보수도 힘듬 덩치가 너무 커져 구동시간이 늘어남 일부분의 오류가 전체 영향을 미침 각 기능에 따라 다른 언어를 선택할 수 없음 마이크로 서비스 아키텍처(MicroService Architecture) ... </summary> </entry> <entry><title>도메인 주도 설계(DDD)</title><link href="https://asy0239.github.io/posts/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EC%84%A4%EA%B3%84(DDD)/" rel="alternate" type="text/html" title="도메인 주도 설계(DDD)" /><published>2022-04-10T09:12:00+09:00</published> <updated>2022-04-10T09:12:00+09:00</updated> <id>https://asy0239.github.io/posts/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EC%84%A4%EA%B3%84(DDD)/</id> <content src="https://asy0239.github.io/posts/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EC%84%A4%EA%B3%84(DDD)/" /> <author> <name>asy</name> </author> <category term="DDD" /> <summary> 이번 포스팅은 도메인 주도 설계를 간단하게 정리합니다. 도메인 주도 설계의 핵심은 아래와 같습니다. 도메인 전문가(기획자)와 개발자가 어떻게 협업할 것인지가 중요 보편 언어 : 누구나 이해할 수 있는 언어를 사용 모델 주도 디자인 도메인 이란? 사전적 의미로 영역, 집합 비즈니스 Domain 을 의미 예를 들어 주문, 고객, 주소관리 등등과 같이 분리 실제 사건이 발생하는 집합 DDD 의 2가지 종류 전략적 설계 비즈니스의 상황(Context : 대상자, 상황)에 맞게 설계 모든 Context 를 이벤트 스토밍을 통해 공유 각 Context 를 그룹핑(Bounded Context) Context Mapping 을 통해 Bounded Contex... </summary> </entry> <entry><title>마이크로 서비스 통신 패턴</title><link href="https://asy0239.github.io/posts/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%86%B5%EC%8B%A0-%ED%8C%A8%ED%84%B4/" rel="alternate" type="text/html" title="마이크로 서비스 통신 패턴" /><published>2022-04-04T09:12:00+09:00</published> <updated>2022-04-04T09:12:00+09:00</updated> <id>https://asy0239.github.io/posts/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%86%B5%EC%8B%A0-%ED%8C%A8%ED%84%B4/</id> <content src="https://asy0239.github.io/posts/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%86%B5%EC%8B%A0-%ED%8C%A8%ED%84%B4/" /> <author> <name>asy</name> </author> <category term="마이크로서비스" /> <summary> Synchronous Solution(동기적) REST API 서비스 A 에서 서비스 B 로 직접 요청을 보내고 동기적으로 응답을 기다림 Asynchronous Messaging(비동기적) 메시지 브로커를 사용하여 서비스 A 에서 서비스 B 로 메시지를 보냄 서비스 A 는 응답을 기다리지 않음 서비스 B 는 일반적으로 동일한 메시징 시스템을 통해 결과를 사용할 수 있을 때 (결과가 예상되는 경우) 결과를 보냄 RabbitMQ, Apache Kafka Synchronous Solution 의 문제점 Request 하는 Service A 와 Response 하는 Service B 2 개의 Service 가 있을 때 경우 A가 연결을 시도할 때 B가 오프라인 상... </summary> </entry> <entry><title>CI/CD 소개</title><link href="https://asy0239.github.io/posts/CI-CD-%EC%86%8C%EA%B0%9C/" rel="alternate" type="text/html" title="CI/CD 소개" /><published>2022-03-04T07:32:30+09:00</published> <updated>2022-03-04T07:32:30+09:00</updated> <id>https://asy0239.github.io/posts/CI-CD-%EC%86%8C%EA%B0%9C/</id> <content src="https://asy0239.github.io/posts/CI-CD-%EC%86%8C%EA%B0%9C/" /> <author> <name>asy</name> </author> <category term="CI CD" /> <summary> CI/CD Concept CI (Continuous Integration) - 지속적 통합 CD (Continuous Delivery or Continuous Deployment) - 지속적 전달 / 배포 소프트웨어 배포 프로세스를 스피드하게하기 위해 프로세스 주기를 짧게하고 자동화된 방식을 채택한 것을 CI/CD 라고 합니다. CI 소스 병합 시 Conflict 를 방지하기 위해서 하루에 수차례 Merge 하는 것을 CI 라고 합니다. 전통적인 소프트웨어 방식이 보완하기 위해 CI 라는 개념이 나옴 CI WorkFlows Developer 개발자들이 Local 환경에서 개발 후 Repository 에 Push Reposito... </summary> </entry> </feed>
